# 5장. 트랜잭션과 잠금


MySQL의 **동시성**에 영향을 미치는 요소: Transaction, 잠금(Lock), Transaction의 격리 수준

# 1. 트랜잭션

## 1) MySQL에서의 트랜잭션

MySQL은 스토리지 엔진에 따라 Transaction을 지원하기도, 지원하지 않기도 한다.

- **Transaction을 지원하지 않은 MyISAM**
    
    부분 업데이트(Partial Update) 현상 ⇒ 정합성 맞추기 어렵다.
    
- T**ransaction을 지원하는 InnoDB의 처리 방식**
    
    간단한 코드로 트랜잭션 처리가 가능하다.
    

## 2) 주의사항

- **프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위**와 트랜잭션이 활성화돼 있는 프로그램의 범위를 **최소화**해야 한다는 것이다.
    
    DB connection 개수 제한
    
    ⇒ Connection이 필요 없는 작업에선 연결을 해제하여 프로그램이 connection을 가지기 위해 기다리는 상황을 줄인다.
    
- 프로그램의 코드에서 라인 수는 한두 줄이라고 하더라도 **네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제**해야한다.
    
    네트워크를 통한 연결이 끊기는 상황이 발생할 수 있다.
    
    ⇒ 작업의 성격이 다른 경우, 다른 트랜잭션으로 분리한다.
    

# 2. 잠금(Lock)

MySQL에서 사용하는 잠금은 **MySQL 엔진 레벨**과 **스토리지 엔진 레벨**로 나눌 수 있다.

MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미칠 수 있다.

MySQL 엔진 레벨의 잠금과 달리 스토리지 엔젠 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

## 1) MySQL 엔진의 금

### 글로벌 락

**한 세션에서 글로벌 락을 획득**하면 다른 세션에서 SELECT를 제외한 대부분의 DDL문장이나 DML문장을 실행하는 경우 **글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다**.

글로벅 락이 영향을 미치는 범위는 **MySQL 서버 전체**이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

**언제 사용하는가?**

여러 DB에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받을 때

즉, 트랜잭션을 지원하지 않는 스토리지 엔진에서 일관된 데이터 상태를 유지해야 할 때

**백업 락의 도입**

트랜잭션을 지원하는 InnoDB 스토리지 엔진이 일반화되면서 등장한 가벼운 형태의 글로벌 락.

백업 도중 DDL이 실행되면 백업이 실패하는 것을 보완한다.

### 테이블 락: 개별 테이블 단위로 설정되는 잠금

명시적 또는 묵시적으로 테이블락을 획득할 수 있다.

- **명시적 테이블락**
    
    글로벌락과 동일하게 온라인 작업에 상당한 영향을 미쳐 특별한 상황이 아니면 어플리케이션에서 사용할 필요가 없다.
    
- **묵시적 테이블락**
    
    MyISAM이나 MEMORY 테이블에서 데이터를 변경하는 쿼리를 실행할 때 발생한다.
    

### 네임드 락: 문자열에 대한 잠금

잠금대상이 데이터베이스 객체가 아닌 사용자가 지정한 문자열이다.

여러 클라이언트가 상호 동기화 처리해야할 때 사용할 수 있다.

### 메타데이터 락: DB 객체를 변경할 때 획득하는 잠금

아래와 같이 테이블의 이름을 바꾸기 위해 두 명령어로 나누어 설정하면 아주 짧은 시간 Table not found 오류가 발생할 수 있다.

```sql
RENAME TABLE rank to rank_bakcup;
RENAME TABLE rank_new TO rank;
```

두 명령문을 한번에 실행하면 원본이름과 변경될 테이블의 이름에 모두 잠금을 설정하여 오류없이 적용할 수 있다.

```sql
RENAME TABLE rank to rank_bakcup, rank_new TO rank;
```

**메타데이터 잠금 + InnoDB 트랜잭션**

로그 테이블은 웹 서버의 접근 로그만 저장하여 UPDATE, DELETE 없이 INSERT만 실행된다.

로그 테이블의 구조를 변경하기 위해 다음과 같은 방법을 사용할 수 있다.

1. **Online DDL을 통한 구조 변경**
    
    단일 스레드로 동작하여 많은 시간이 소모된다.
    
2. **새로운 구조 테이블을 생성하고 pk의 범위로 나누어 여러 스레드로 복사**
    
    작업 1에서 PK의 범위에 따라 빠르게 복사가 이루어진다.
    
    작어 2에서 transaction과 테이블 잠금, RENAME TABLE 명령으로 응용 프로그램의 중단 없이 운용 중이 테이블의 구조를 변경할 수 있다.
    
    ![메타데이터](https://user-images.githubusercontent.com/55950561/228074408-8e44586b-c3d7-4db2-a803-340ed16cde8b.png)

## 2) InnoDB 스토리지 엔진 잠금

### InnoDB 스토리지 엔진의 잠금

InnoDB 스토리지 엔진은 잠금 정보를 **작은 공간으로 관리**하는 **레코드 기반의 잠금 기능**을 제공한다.

따라서 lock escalation(레코드락인 페이지락이나 테이블락으로 레벨 업되는 경우)은 없다.

InnoDB의 잠금 종류로는 레코드 락, 갭 락, 넥스트 키 락, 자동 증가 락이 있다.

- **레코드 락**
    
    레코드 자체만을 잠그는 락.
    
    InnoDB 스토리지 엔진은 엔진 레코드 자체가 아니라 **인덱스 레코드를 잠금다**.
    
    테이블에 인덱스가 없어도 내부적으로는 클러스터 인덱스를 가지고 있어 이를 이용해 잠금을 설정한다.
    
- **갭 락**
    
    레코드와 **인접한 레코드 사이의 간격을 잠근다**.
    
    두 레코드 사이에 새로운 레코드가 Insert되는 것을 제어한다.
    
- **넥스트 키 락**
    
    레코드락 + 갭 락
    
- **자동 증가 락**
    
    AUTO_INCREMENT 컬럼 속성으로 인해 제공하는 테이블 수준의 잠금.
    
    INSERT, REPLACE 시에 AUTO_INCREMENT가 설정된 컬럼이 있는 경우, 아주 짧은 시간 락이 걸렸다 해제된다.
    

### 인덱스와 잠금

Record Lock에서 레코드가 아닌 인덱스를 잠그는 방식으로 처리된다.

업에이트 시 WHERE 절에 있는 인덱스 중 인덱스를 가지고 있는 컬럼의 인덱스에 락을 건다.

`SELECT COUNT(*) FROM employees WHERE first_name='Georgi' AND last_name='Klassen'` 에서 first_name에만 인덱스가 있을 때, `first_name=’Gerorgi’`인 모든 컬럼에 락을 걸어야 한다.

**테이블에 인덱스가 없다면?**

테이블을 풀 스캔하면서 update 작업이 일어난다. WHERE절의 조건을 만족하는 하나의 레코드를 선택하기 위해, first_name 조건을 만족하는 많은 레코드를 모두 잠궈야 한다.

### 레코드 수준의 잠금 확인 및 해제

`SELECT * FROM information_schema.innodb_locks;` 을 통해 잠금을 가진 스레드를 상세히 확인할 수 있다.

# 3. MySQL의 격리 수준

## 1) Read Uncommitted

## 2) Read Committed

## 3) Repeatable Read

## 4) Serializable

---

<이미지 출처>

- [https://neverfadeaway.tistory.com/62?category=1155974](https://neverfadeaway.tistory.com/62?category=1155974)
