# 8장. 인덱스
DBMS에서 인덱스는 **데이터의 저장(Insert, Update, Delete) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능**이다.

column의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스로 만들고, column의 값을 미리 정렬해 보관하여 원하는 데이터에 빠르게 접근할 수 있도록 한다.

# 1. B-Tree 인덱스

## 1) 구조 및 특성
![B-Tree 구조](https://user-images.githubusercontent.com/55950561/228147018-29f143d6-d2cb-4f04-965f-1a627f69b5bf.png)

Database에서는 **인덱스와 실제 데이터가 저장된 데이터는 따로 관리**된다. 인덱스의 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

인덱스는 정렬되어 있지만, 실제 데이터 파일의 레코드는 임의의 순서로 저장되어 있다.

각 스토리지 엔진에서 secondary index를 통해 레코드를 찾는 방법에 차이가 있다.

- **MyISAM:** secondary index가 물리적인 주소를 가짐
- **InnoDB:** primary key를 주소처럼 사용하여 레코드에 접근
    
    secondary 인덱스 검색에서 데이터 레코드를 읽기 위해 프라이머리 키를 저장하고 있는 B-Tree를 다시 검색해야 한다.
    

## 2) B-Tree 인덱스 키 추가 및 삭제

### 추가

Insert를 수행했을 때 B-Tree에 저장하는 과정은 다음과 같다.

1. B-Tree에서 키 값이 저장될 위치를 검색한다.
2. 리프노드에 레코드의 키 값과 주소 정보를 저장한다.
    
    만약, 리프노드에 더 저장할 공간이 없을 때에는 리프노드를 분리(split)한다.
    

MySQL의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장되기도 그렇지 않기도 하다.

- **MyISAM이나 MEMORY 스토리지 엔진**
    
    INSERT문장이 실행되면 즉시 새로운 키 값을 B-Tree에 삽입한다.
    
    B-Tree에 키를 추가하는 작업이 완료될 때까지 클라이언트는 쿼리의 결과를 받지 못하고 기다린다.
    
- **InnoDB**
    
    필요에 따라 즉시 처리하기도, 키 추가 작업을 지연시키기도 한다.
    
    pk나 유니크 인덱스는 중복체크가 필요하므로 즉시 B-Tree에 추가한다.
    

### 삭제

삭제 작업은 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크만 하면 작업이 완료된다.

InnoDB의 경우 지연 처리할 수도 있지만 사용자에게 영향을 미치진 않는다.

### 변경

키 값 삭제 → 새로운 키 값 추가

### 검색

B-Tree의 가장 주된 목적은 빠른 검색이다.

루트노드부터 리프노드까지 **트리를 탐색**해 나가며 비교 작업을 수행한다.

그러나 비교 연산에서 항상 B-Tree의 장점을 이용할 수 있는 것은 아니다.

- **100% 일치 또는 값의 앞부분 일치, 부등호 연산**
    
    이 경우 B-Tree의 장점을 활용할 수 있다.
    
- **함수나 연산 수행 결과로 정렬하거나 검색하는 연산**
    
    키 값에 변형이 있는 경우 변형된 값과 인덱스에 저장되어 있는 값이 달라 빠른 검색을 할 수 없다.
    

**InnoDB에서 인덱스의 중요성**

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다.

적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

## 3) B-Tree 인덱스 사용에 영향을 미치는 요소

### 인덱스 키 값의 크기

B-Tree에서 자식 노드의 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.

키 값의 크기가 커지면 → 한 페이지에 저장되는 인덱스의 수가 줄어들고 → 메모리에 cache할 수 있는 레코드 수가 줄어들고 → 디스크 접근 횟수가 많아지고 → 결국엔 느려진다.

### B-Tree 깊이

B-Tree의 깊이는 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결된 문제이다.

인덱스의 키 값의 크기가 커지면 → 하나의 인덱스 페이지가 담을 수 있는 키 값의 개수가 적어지고 → B-Tree의 깊이가 깊어지고 → 더 많은 디스크 읽기가 필요하다.

⇒ 인덱스 키 값의 크기는 작게 만드는 것이 좋다.

### 선택도(기수성)

모든 인덱스 가운데 unique한 값의 수로 쿼리의 효율성에 큰 영향을 미친다.

중복된 값이 많으면 → 기수성&선택도 낮아지고 → 검색 대상이 많아진다.

### 읽어야 하는 레코드의 건수

레코드를 읽는 과정을 비용 측면에서 비교해 보면

인덱스를 통해 레코드를 읽는 것 > 테이블에 바로 레코드를 읽는 것. 대락 4~5배 정도의 비용이 차이난다.

인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 직접 테이블을 읽는 것이 효율적이다.

## 4) B-Tree 인덱스를 통한 데이터 읽기

MySQL의 각 스토리지 엔진이 인덱스를 통해 실제 레코드를 읽어내는 대표적인 방법으로 index range scan, index full scan, loose index scan이 있다.

### Index Range Scan

검색하려는 값의 수나 검색 결과 레코드 건수에 관계없이 **검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식**이다.

탐색을 시작할 리프노드를 찾으면 종료 지점까지 리프 노드의 인덱스를 차례로 읽는다(scan).

인덱스 스캔 후 레코드를 정렬된 상태로 가져온다.

리프노드에 해당하는 레코드를 데이터 파일에서 읽어오기 위해 레코드 마다 랜덤 I/O가 발생한다.

### Index Full Scan

인덱스의 처음부터 끝까지 모두 읽는 방식을 말한다.

쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식을 사용한다.

### Loose Index Scan

인덱스를 스캔하며 필요하지 않은 인덱스 값은 무시하고 넘어가며 듬성듬성 읽는 것을 의미한다.

GROUP BY 또는 MAX(), MIN() 함수에 대해 최적화 하는 경우에 사용된다.

## 5) 다중 칼럼(Multi-column) 인덱스

다중 컬럼 인덱스 또는 concatenated index는 **2개 이상의 column을 사용하여 인덱스를 구성**한 것을 말한다.

다중 컬럼 인덱스에서 각 컬럼의 위치는 중요하다.

∵ 인덱스 컬럼 순서대로 1차 정렬 기준, 2차 정렬 기준··· 으로 이해할 수 있다.

⇒ 인덱스의 두 번쨰 컬럼은 첫 번째 컬럼에 의해서 정렬되어 있다.

## 6) B-Tree 인덱스의 정렬 및 스캔 방향

### 인덱스의 정렬

MySQL 5.7부터 인덱스의 정렬 순서(ASC, DESC)를 지정할 수 있다.

MySQL 8.0부터 인덱스를 복합인덱스에 각 컬럼마다 정렬 순서를 정할 수 있다.

### 인덱스의 정렬과 스캔

인덱스에서 양방향으로 스캔할 수 있다.

따라서 정렬 순서와 관계없이 인덱스를 읽을 방향은 옵티마이저가 실시간으로 결정한다.

### 인덱스의 정순 스캔과 역순 스캔
![인덱스 스캔](https://user-images.githubusercontent.com/55950561/228147064-ae8afbbc-0e4e-44e4-afbd-979f238de310.png)

- **정순 스캔**
    
    인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
    
    인덱스 생성시 결정한 정렬 방향과 일치하는 방향으로 읽는 경우
    
- **역순 스캔**
    
    인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
    
    인덱스 생성시 결정한 정렬 방향과 반대되는 방향으로 읽는 경우
    

정순 스캔과 역순 스캔은 다음 두가지 이유로 성능에 차이가 생긴다.

- **페이지 잠금이 인덱스 정순 스캔에 적한 구조**
- **페이지 내에서 인덱스 레코드가 단방향으로 연결된 구조**

## 7) B-Tree 인덱스의 가용성과 효율성

### 비교 조건의 종류와 효율성

비교 조건의 종류에는 두 가지가 있다.

- **작업 범위 결정 조건**
    
    부등호와 같이 작업의 범위를 결정하는 조건
    
- **필터링 조건(체크 조건)**
    
    동등비교(=)와 같이 비교 작업의 범위를 줄이지 못하고 거름종이의 역할을 하는 조건
    

쿼리에서 작업 범위를 결정하는 조건이 많으면 ⇒ 쿼리 처리 성능을 높이지만, 체크 조건은 쿼리의 성능을 느리게 만들기도 한다.

### 인덱스의 가용성

B-Tree 인덱스는 왼쪽부터 값이 정렬되어 있다.

정렬되어 있어 검색에 유용한 B-Tree의 장점을 활용하지 못하는 경우는 다음과 같다.

- **한 컬럼 내에서 검색할 때 왼쪽이 특정되어 있지 않을 때**
    
    (e.g. `LIKE %hi`),
    
- **복합 컬럼 인덱스에서 선행 칼럼 조건 없이 뒤에 나오는 컬럼을 검색할 때**

---

<이미지 출처>

- [http://wiki.gurubee.ㅉnet/pages/viewpage.action?pageId=26745270&](http://wiki.gurubee.net/pages/viewpage.action?pageId=26745270&)
